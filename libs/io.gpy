package io

import std

/** Scan a string */
scans := func(prompt: string): string {
    inBuf: [255, byte] = nil

    /** Inline assembly x86: */
    <- "mov eax, 3"        // syscall number for read
    <- "mov ebx, 0"        // file descriptor: stdin
    <- "mov ecx, [rbp-255] // address of the buffer (inBuf)
    <- "mov edx, 255       // buffer size (255)
    <- "syscall"          // call kernel for syscall

    str: string = ""

    for i: int = 0; i < 255; i++ {
        str += inBuf[i]
    }

    return str
}

/** Scan a byte */
scanb := func(prompt: string): byte {
    b: byte

    /** Inline assembly x86 */
    <- "cmp dword[gs:0xC], 1" // Check if the system is 32-bit, or 64-bit
    <- "jne .is64"
    <- "in al, 0x60"
    <- "jmp .done"
    <- ".is64:"
    <- "mov rax, 0x60"
    <- "in al, dx"
    <- ".done:"
    <- "mov byte [rbp-1], al" // Put the read character into b

    return b
}

/** Print a string */
puts := func(s: string) {
    /** Inline assembly x86 */
    <- "mov eax, dword[rbp+4]"     // get the address of the string from the parameter
    <- "mov ebx, 1"           // file descriptor for stdout
    <- "mov ecx, eax"         // address of the string
    <- "mov edx, 0"           // count the length of the string
    <- ".count_loop:"
    <- "cmp byte[ecx+edx], 0" // Check if we've reached the end of the string
    <- "je .print_string"
    <- "inc edx"              // move to the next character
    <- "jmp .count_loop"
    <- ".print_string:"
    <- "mov eax, 4"           // make the syscall for sys_write
    <- "syscall"
}

/** Print an int */
puti := func(n: int) {
    if n == 0 {
        puts("0")
        return
    }

    str: string = ""
    sign: int = 1
    if n < 0 {
        sign = -1
    }

    n *= sign

    while n > 0 {
        str += (n % 10) + '0'
        n /= 10
    }

    if sign == -1 {
        str += "-"
    }

    // reverse the string
    start: int = 0
    end: int = len(str)-1
    tmp: string = ""

    while start < end {
        tmp = str[start]
        str[start] = str[end]
        str[end] = tmp
        start++
        end--
    }

    puts(str)
}

/** Print a float */
putf := func(f: float64) {
    flt: float64 = f
    if f < 0 {
        flt *= -1
        puts("-")
    }

    decimal: float64 = flt % 1
    whole: int = flt - decimal

    puti(whole)
    puts(".")

    // multiply by a power of 10 to remove decimal point
    newDecimal: int = decimal * 10000000000

    puti(newDecimal)
}

/** Print a byte */
putb := func(b: byte) {
    /** Inline assembly x86 */
    <- "mov dl, byte [rbp+4]"
    <- "add dl, 48"
    <- "mov ebx, 1"
    <- "mov ecx, dl"
    <- "mov edx, 1"
    <- "mov eax, 4"
    <- "syscall"
}

/** Print a boolean */
putbl := func(b: bool) {
    if b == 0 {
        puts("false")
    } else {
        puts("true")
    }
}

/** Printing... */
print := func(xyz: ...) {
    i := 0
    x := xyz[i]
    while true {
        if x == 'i' {
            i++
            x = xyz[i]

            puti(x)
        } else if x == 'f' {
            i++ 
            x = xyz[i]

            putf(x)
        } else if x == 'b' {
            i++ 
            x = xyz[i]

            putb(x)
        } else if x == 's' {
            i++ 
            x = xyz[i]

            puts(x)
        } else if x == 'l' {
            i++
            x = xyz[i]

            putbl(x)
        } else if x == 'v' {
            i++
            x = xyz[i]

            puts("[ ")

            while x[i] != '\0' {
                puti(x)
                putb(' ')

                i++
                x = xyz[i]
            }

            puts(" ]")
        } else if x == 'c' {
            i++
            x = xyz[i]

            puts("[ ")

            while x[i] != '\0' {
                putf(x)
                putb(' ')

                i++
                x = xyz[i]
            }

            puts(" ]")
        } else if x == 'x' {
            i++
            x = xyz[i]

            puts("[ ")

            while x[i] != '\0' {
                putb(x)
                putb(' ')

                i++
                x = xyz[i]
            }

            puts(" ]")
        } else if x == 'z' {
            i++
            x = xyz[i]

            puts("[ ")

            while x[i] != '\0' {
                putb('"')
                puts(x)
                putb('"')
                putb(' ')

                i++
                x = xyz[i]
            }

            puts(" ]")
        } else if x == 'n' {
            i++
            x = xyz[i]

            puts("[ ")

            while x[i] != '\0' {
                putbl(x)
                putb(' ')

                i++
                x = xyz[i]
            }

            puts(" ]")
        } else {
            break
        }

        i++
        x = xyz[i]
    }
}

println := func(xyz: ...) {
    print(xyz)
    putb('\n')
}

printerr := func(msg: string) {
    s := msg

    /** Inline assembly x86 */
    <- "mov edx, 1"
    <- "mov ebx, 2"
    <- "mov eax, 4"
    <- "mov ecx, [rbp-1]"
    <- ".next:"
    <- "movzx al, byte [ecx]"
    <- "inc ecx"
    <- "cmp al, 0"
    <- "je .done"
    <- "syscall"
    <- "jmp .next"
    <- ".done:"
}

/** File interactions */
readFile := func(filename: string): [bytes] {
    desc: [4, byte]
    buffer: [4096, byte]

    /** Inline assembly x86 */
    /** Open the file */
    <- "mov eax, 5"
    <- "mov ebc, rbp+1"
    <- "mov ecx, 0"
    <- "syscall"

    /** Store the descriptor */
    <- "mov [rbp-4], eax"

    /** Read from file */
    <- "mov eax, 3"
    <- "mov ebx, [rbp-4]"
    <- "mov ecx, [rbp-4100]"
    <- "mov edx, 4096"
    <- "syscall"

    /** Close the file */
    <- "mov eax, 6"
    <- "mov ebx, [rbp-4]"
    <- "syscall"

    return buffer
}

writeToFile := func(filename: string, bytes [byte]) {
    fnlen := len(filename)
    bylen := len(bytes)
    fd: [4, byte]

    /** Inline assembly x86 */
    <- "mov rsi, 0102o" // O_CREAT
    <- "mov rdx, 0666o" // umode_t
    <- "mov rax, 2"
    <- "syscall"
    <- "mov [rbp-12], rax"
    <- "mov rdx, [rbp-8]"   // message length
    <- "mov eax, [rbp-4]"   
    <- "mov rsi, [rbp+eax]" // message to write
    <- "mov rdi, [rbp-12]"  // file descriptor
    <- "mov rax, 1"         // system call number (sys_write)
    <- "syscall"            // call kernel
    <- "mov rdi, [rbp-12]"
    <- "mov rax, 3"         // sys_close
    <- "syscall"
}